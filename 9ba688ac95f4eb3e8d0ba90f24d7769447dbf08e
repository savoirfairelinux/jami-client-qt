{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "8cbfffc9_e2533e4c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 610
      },
      "writtenOn": "2023-04-30T12:22:47Z",
      "side": 1,
      "message": "A bit offtopic, but design of VideoProvider looks suspicious to me.\n\n1. Why to use pointers here? It is a private structure, that is used by VideoProvider exclusively. And QVideoFrame is explicitly shared, as documentation says.\n```\n    struct FrameObject\n    {\n        std::unique_ptr\u003cQVideoFrame\u003e videoFrame;\n        QMutex mutex;\n        QSet\u003cQVideoSink*\u003e subscribers;\n    };\n    std::map\u003cQString, std::unique_ptr\u003cFrameObject\u003e\u003e framesObjects_;\n```\n\n2. Why two mutexes if we need three to be thread-safe?\n  a) One for adding and removing renderers.\n  b) One for adding and removing subscribers.\n  c) One for modifying QVideoFrame.\n\n3. Why QMutex instead of QReadWriteLock? Don\u0027t see any reason why a frame can\u0027t be read by multiple threads simultaneously. And for different frames locking-free reading is a must.\n\n4. Why to duplicate data in activeRenderers_ (and protect it by a mutex by the way) if it can be easily generated on demand?\n\nSo in my opinion the right design should look like this:\n```\nclass VideoProvider final : public QObject\n{\n    Q_OBJECT\n    QML_ELEMENT\npublic:\n    explicit VideoProvider(AVModel\u0026 avModel, QObject* parent \u003d nullptr);\n    ~VideoProvider() \u003d default;\n\n    Q_INVOKABLE void subscribe(QObject* obj, const QString\u0026 id \u003d {});\n    Q_INVOKABLE void unsubscribe(QObject* obj);\n    Q_INVOKABLE QString captureVideoFrame(const QString\u0026 id);\n    Q_INVOKABLE QImage captureRawVideoFrame(const QString\u0026 id);\n    \n    Q_PROPERTY(QVariantMap renderers READ getRenderers NOTIFY renderersChanged)\n    QVariantMap getRenderers() {\n        QVariantMap map;\n        for (auto\u0026 r : renderers_) {\n            map[r.first] \u003d r.second.videoFrame.size();\n        }\n        return map;\n    }\n    Q_SIGNAL void renderersChanged();\n\nprivate Q_SLOTS:\n    void onRendererStarted(const QString\u0026 id, const QSize\u0026 size);\n    void onFrameBufferRequested(const QString\u0026 id, AVFrame* avframe);\n    void onFrameUpdated(const QString\u0026 id);\n    void onRendererStopped(const QString\u0026 id);\n\nprivate:\n    QVideoFrame* frame(const QString\u0026 id);\n    void copyUnaligned(QVideoFrame* dst, const video::Frame\u0026 src);\n    AVModel\u0026 avModel_;\n\n    struct FrameObject\n    {\n        QVideoFrame videoFrame;\n        QReadWriteLock frameMutex;\n        QSet\u003cQVideoSink*\u003e subscribers;\n        QReadWriteLock subscribersMutex;\n    };\n    std::map\u003cQString, FrameObject\u003e renderers_;\n    QReadWriteLock renderersMutex_;\n};\n```\n\nAnd now if we add double buffering like this:\n```\nclass VideoProvider final : public QObject\n{\n    Q_OBJECT\n    QML_ELEMENT\npublic:\n    explicit VideoProvider(AVModel\u0026 avModel, QObject* parent \u003d nullptr);\n    ~VideoProvider() \u003d default;\n\n    Q_INVOKABLE void subscribe(QObject* obj, const QString\u0026 id \u003d {});\n    Q_INVOKABLE void unsubscribe(QObject* obj);\n    Q_INVOKABLE QString captureVideoFrame(const QString\u0026 id);\n    Q_INVOKABLE QImage captureRawVideoFrame(const QString\u0026 id);\n    \n    Q_PROPERTY(QVariantMap renderers READ getRenderers NOTIFY renderersChanged)\n    QVariantMap getRenderers() {\n        QVariantMap map;\n        for (auto\u0026 r : renderers_) {\n            map[r.first] \u003d r.second.videoFrame.size();\n        }\n        return map;\n    }\n    Q_SIGNAL void renderersChanged();\n\nprivate Q_SLOTS:\n    void onRendererStarted(const QString\u0026 id, const QSize\u0026 size);\n    void onFrameBufferRequested(const QString\u0026 id, AVFrame* avframe);\n    void onFrameUpdated(const QString\u0026 id);\n    void onRendererStopped(const QString\u0026 id);\n\nprivate:\n    QVideoFrame* frame(const QString\u0026 id);\n    void copyUnaligned(QVideoFrame* dst, const video::Frame\u0026 src);\n    AVModel\u0026 avModel_;\n\n    struct FrameObject\n    {\n        QVideoFrame frame1;\n        QVideoFrame frame2;\n        QSet\u003cQVideoSink*\u003e subscribers;\n        QReadWriteLock subscribersMutex;\n        std::atomic_flag indicator; // true  \u003d read from frame1, write to frame2\n                                    // false \u003d read from frame2, write to frame1\n    };\n    std::map\u003cQString, FrameObject\u003e renderers_;\n    QReadWriteLock renderersMutex_;\n};\n```\n\nHere I assume that we have one writer and multiple readers, which is our use-case. For multiple writers they should be serialized by a QReadWriteLock as earlier.\n\nDid I miss something and there is a reason to complicate things here?",
      "revId": "9ba688ac95f4eb3e8d0ba90f24d7769447dbf08e",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a760b030_00e5ec91",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 90
      },
      "writtenOn": "2023-05-02T23:16:58Z",
      "side": 1,
      "message": "Thanks for the great review! It\u0027s actually quite on-topic. There\u0027s definitely a lot to improve on here, and I\u0027m not convinced this approach is valid anyways. The previous implementation was storing QImages and using QQuickPaintedItem::paint which was quite complex and buggy (https://review.jami.net/c/jami-client-qt/+/21075). The objective is obviously to minimize frame copies, and it seems a QQuickItem::updatePaintNode/QSGNode approach will be better. If you have any insight or suggestions, please let me know.\n\nAnyway, to address your points:\n\n1. Pointers are used in order to reset the frame size/format or allow QML component subscriptions to endure beyond the render cycles. Definitely possible that there is a better way to do this, but I think that redesign should be done in tandem with QML component design.\n\n2/3. Agreed. Thanks for suggesting QReadWriteLock. I will do an overhaul on the synchronization in VideoProvider for now. I see QMutex is used without regard for not blocking multiple readers throughout the client code. There are several places where that may be more critical.\n\n4. Emitting renderersChanged would queue calls to getRenderers from each VideoView. Should be revisited but not critical afaics, as it\u0027s only used to control the visibility/opacity effect of the VideoView and avoid showing stale a buffer.\n\nI\u0027ll keep you posted on related fixes. I\u0027ll be applying some of your suggestions in other video-related patches.",
      "parentUuid": "8cbfffc9_e2533e4c",
      "revId": "9ba688ac95f4eb3e8d0ba90f24d7769447dbf08e",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9332b209_06711edc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 610
      },
      "writtenOn": "2023-05-03T09:41:31Z",
      "side": 1,
      "message": "\u003e Pointers are used in order to reset the frame size/format or allow QML component subscriptions to endure beyond the render cycles.  \n  \nDon\u0027t see a problem to make it entirely on stack:  \n\n```\nstruct { QVideoFrame frame; } object;\nobject.frame \u003d QVideoFrame(newFormat);\n```\n  \nAs documentation says, `QExplicitlySharedDataPointer implements thread-safe reference counting`, so already published frames will not change and will be owned by QVideoSink\u0027s only until they get new frames.",
      "parentUuid": "a760b030_00e5ec91",
      "revId": "9ba688ac95f4eb3e8d0ba90f24d7769447dbf08e",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "47d398e6_6b2db5e4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 90
      },
      "writtenOn": "2023-05-04T14:53:23Z",
      "side": 1,
      "message": "Okay nice that\u0027ll simplify the code regarding QVideoFrame. The mutexes will need to be in a moveable container, or we can keep the std::map\u003cQString, std::unique_ptr\u003cFrameObject\u003e\u003e.",
      "parentUuid": "9332b209_06711edc",
      "revId": "9ba688ac95f4eb3e8d0ba90f24d7769447dbf08e",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f05dab16_c66afb42",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 610
      },
      "writtenOn": "2023-05-04T16:24:13Z",
      "side": 1,
      "message": "\u003e The objective is obviously to minimize frame copies, and it seems a QQuickItem::updatePaintNode/QSGNode approach will be better.\n\nYes, I think writing a custom QQuickItem that displays daemon\u0027s native frames is the only solution to avoid copies, because QVideoFrame in Qt6 can\u0027t wrap existing video buffers (WTF? QVideoFrame in Qt5 allows to do this easily).\n\nAbout the overall model, I think the pull model [1] for pipeline is more appropriate because a sink gets an actual frame to display without additional latency. Also it avoids extra work when frames are not needed by clients (for example, a main window of a client is hidden by other windows). Currently the daemon use the push model, as I see.\n\nTo avoid flickering with the pull model the daemon should implement double buffering. So in fact we should implement a VideoProvider in the daemon. The advantage here is that the clients should not worry about synchronization. The frames can be requested from any thread at any time, immediately rendered and forgotten until the next cycle. The disadvantage is that all clients should implement a custom widget to work with the daemon.\n\nThe draft for the daemon:\n```\nnamespace jami {\n\nclass VideoProvider\n{\npublic:\n    AVFrame* frame(std::size_t index) {\n        std::shared_lock lock(framesMutex_);\n        auto frames \u003d frames_[index];\n        std::shared_lock lock(frames.mutex_);\n        if (frames.flag) {\n            return frame1;\n        } else {\n            return frame2;\n        }\n    }\n\n    AVFrame* captureFrame(std::size_t index) {\n        std::shared_lock lock(framesMutex_);\n        auto frames \u003d frames_[index];\n        auto* frame \u003d av_frame_alloc();\n        std::unique_lock lock(frames.mutex_); // to block a writer until we make a copy\n        ...\n        return frame;\n    }\n\nprivate:\n    struct Frames {\n        AVFrame* frame1;\n        AVFrame* frame2;\n        std::shared_mutex mutex_;\n        bool flag;\n    };\n    std::vector\u003cFrames\u003e frames_;\n    std::shared_mutex framesMutex_;\n}\n\n}\n```\n\nWhat do you think?\n\nAnd of course if the daemon and clients are different processes (like with DBus) we can just use Pipewire :).\n\n[1] https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/FAQ/#are-you-using-a-push-or-pull-model-for-scheduling",
      "parentUuid": "47d398e6_6b2db5e4",
      "revId": "9ba688ac95f4eb3e8d0ba90f24d7769447dbf08e",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    }
  ]
}