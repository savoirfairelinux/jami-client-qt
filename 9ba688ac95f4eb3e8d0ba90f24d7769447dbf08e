{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "8cbfffc9_e2533e4c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 610
      },
      "writtenOn": "2023-04-30T12:22:47Z",
      "side": 1,
      "message": "A bit offtopic, but design of VideoProvider looks suspicious to me.\n\n1. Why to use pointers here? It is a private structure, that is used by VideoProvider exclusively. And QVideoFrame is explicitly shared, as documentation says.\n```\n    struct FrameObject\n    {\n        std::unique_ptr\u003cQVideoFrame\u003e videoFrame;\n        QMutex mutex;\n        QSet\u003cQVideoSink*\u003e subscribers;\n    };\n    std::map\u003cQString, std::unique_ptr\u003cFrameObject\u003e\u003e framesObjects_;\n```\n\n2. Why two mutexes if we need three to be thread-safe?\n  a) One for adding and removing renderers.\n  b) One for adding and removing subscribers.\n  c) One for modifying QVideoFrame.\n\n3. Why QMutex instead of QReadWriteLock? Don\u0027t see any reason why a frame can\u0027t be read by multiple threads simultaneously. And for different frames locking-free reading is a must.\n\n4. Why to duplicate data in activeRenderers_ (and protect it by a mutex by the way) if it can be easily generated on demand?\n\nSo in my opinion the right design should look like this:\n```\nclass VideoProvider final : public QObject\n{\n    Q_OBJECT\n    QML_ELEMENT\npublic:\n    explicit VideoProvider(AVModel\u0026 avModel, QObject* parent \u003d nullptr);\n    ~VideoProvider() \u003d default;\n\n    Q_INVOKABLE void subscribe(QObject* obj, const QString\u0026 id \u003d {});\n    Q_INVOKABLE void unsubscribe(QObject* obj);\n    Q_INVOKABLE QString captureVideoFrame(const QString\u0026 id);\n    Q_INVOKABLE QImage captureRawVideoFrame(const QString\u0026 id);\n    \n    Q_PROPERTY(QVariantMap renderers READ getRenderers NOTIFY renderersChanged)\n    QVariantMap getRenderers() {\n        QVariantMap map;\n        for (auto\u0026 r : renderers_) {\n            map[r.first] \u003d r.second.videoFrame.size();\n        }\n        return map;\n    }\n    Q_SIGNAL void renderersChanged();\n\nprivate Q_SLOTS:\n    void onRendererStarted(const QString\u0026 id, const QSize\u0026 size);\n    void onFrameBufferRequested(const QString\u0026 id, AVFrame* avframe);\n    void onFrameUpdated(const QString\u0026 id);\n    void onRendererStopped(const QString\u0026 id);\n\nprivate:\n    QVideoFrame* frame(const QString\u0026 id);\n    void copyUnaligned(QVideoFrame* dst, const video::Frame\u0026 src);\n    AVModel\u0026 avModel_;\n\n    struct FrameObject\n    {\n        QVideoFrame videoFrame;\n        QReadWriteLock frameMutex;\n        QSet\u003cQVideoSink*\u003e subscribers;\n        QReadWriteLock subscribersMutex;\n    };\n    std::map\u003cQString, FrameObject\u003e renderers_;\n    QReadWriteLock renderersMutex_;\n};\n```\n\nAnd now if we add double buffering like this:\n```\nclass VideoProvider final : public QObject\n{\n    Q_OBJECT\n    QML_ELEMENT\npublic:\n    explicit VideoProvider(AVModel\u0026 avModel, QObject* parent \u003d nullptr);\n    ~VideoProvider() \u003d default;\n\n    Q_INVOKABLE void subscribe(QObject* obj, const QString\u0026 id \u003d {});\n    Q_INVOKABLE void unsubscribe(QObject* obj);\n    Q_INVOKABLE QString captureVideoFrame(const QString\u0026 id);\n    Q_INVOKABLE QImage captureRawVideoFrame(const QString\u0026 id);\n    \n    Q_PROPERTY(QVariantMap renderers READ getRenderers NOTIFY renderersChanged)\n    QVariantMap getRenderers() {\n        QVariantMap map;\n        for (auto\u0026 r : renderers_) {\n            map[r.first] \u003d r.second.videoFrame.size();\n        }\n        return map;\n    }\n    Q_SIGNAL void renderersChanged();\n\nprivate Q_SLOTS:\n    void onRendererStarted(const QString\u0026 id, const QSize\u0026 size);\n    void onFrameBufferRequested(const QString\u0026 id, AVFrame* avframe);\n    void onFrameUpdated(const QString\u0026 id);\n    void onRendererStopped(const QString\u0026 id);\n\nprivate:\n    QVideoFrame* frame(const QString\u0026 id);\n    void copyUnaligned(QVideoFrame* dst, const video::Frame\u0026 src);\n    AVModel\u0026 avModel_;\n\n    struct FrameObject\n    {\n        QVideoFrame frame1;\n        QVideoFrame frame2;\n        QSet\u003cQVideoSink*\u003e subscribers;\n        QReadWriteLock subscribersMutex;\n        std::atomic_flag indicator; // true  \u003d read from frame1, write to frame2\n                                    // false \u003d read from frame2, write to frame1\n    };\n    std::map\u003cQString, FrameObject\u003e renderers_;\n    QReadWriteLock renderersMutex_;\n};\n```\n\nHere I assume that we have one writer and multiple readers, which is our use-case. For multiple writers they should be serialized by a QReadWriteLock as earlier.\n\nDid I miss something and there is a reason to complicate things here?",
      "revId": "9ba688ac95f4eb3e8d0ba90f24d7769447dbf08e",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a760b030_00e5ec91",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 90
      },
      "writtenOn": "2023-05-02T23:16:58Z",
      "side": 1,
      "message": "Thanks for the great review! It\u0027s actually quite on-topic. There\u0027s definitely a lot to improve on here, and I\u0027m not convinced this approach is valid anyways. The previous implementation was storing QImages and using QQuickPaintedItem::paint which was quite complex and buggy (https://review.jami.net/c/jami-client-qt/+/21075). The objective is obviously to minimize frame copies, and it seems a QQuickItem::updatePaintNode/QSGNode approach will be better. If you have any insight or suggestions, please let me know.\n\nAnyway, to address your points:\n\n1. Pointers are used in order to reset the frame size/format or allow QML component subscriptions to endure beyond the render cycles. Definitely possible that there is a better way to do this, but I think that redesign should be done in tandem with QML component design.\n\n2/3. Agreed. Thanks for suggesting QReadWriteLock. I will do an overhaul on the synchronization in VideoProvider for now. I see QMutex is used without regard for not blocking multiple readers throughout the client code. There are several places where that may be more critical.\n\n4. Emitting renderersChanged would queue calls to getRenderers from each VideoView. Should be revisited but not critical afaics, as it\u0027s only used to control the visibility/opacity effect of the VideoView and avoid showing stale a buffer.\n\nI\u0027ll keep you posted on related fixes. I\u0027ll be applying some of your suggestions in other video-related patches.",
      "parentUuid": "8cbfffc9_e2533e4c",
      "revId": "9ba688ac95f4eb3e8d0ba90f24d7769447dbf08e",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9332b209_06711edc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 610
      },
      "writtenOn": "2023-05-03T09:41:31Z",
      "side": 1,
      "message": "\u003e Pointers are used in order to reset the frame size/format or allow QML component subscriptions to endure beyond the render cycles.  \n  \nDon\u0027t see a problem to make it entirely on stack:  \n\n```\nstruct { QVideoFrame frame; } object;\nobject.frame \u003d QVideoFrame(newFormat);\n```\n  \nAs documentation says, `QExplicitlySharedDataPointer implements thread-safe reference counting`, so already published frames will not change and will be owned by QVideoSink\u0027s only until they get new frames.",
      "parentUuid": "a760b030_00e5ec91",
      "revId": "9ba688ac95f4eb3e8d0ba90f24d7769447dbf08e",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "47d398e6_6b2db5e4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 90
      },
      "writtenOn": "2023-05-04T14:53:23Z",
      "side": 1,
      "message": "Okay nice that\u0027ll simplify the code regarding QVideoFrame. The mutexes will need to be in a moveable container, or we can keep the std::map\u003cQString, std::unique_ptr\u003cFrameObject\u003e\u003e.",
      "parentUuid": "9332b209_06711edc",
      "revId": "9ba688ac95f4eb3e8d0ba90f24d7769447dbf08e",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    }
  ]
}