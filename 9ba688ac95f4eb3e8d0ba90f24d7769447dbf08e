{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "8cbfffc9_e2533e4c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 610
      },
      "writtenOn": "2023-04-30T12:22:47Z",
      "side": 1,
      "message": "A bit offtopic, but design of VideoProvider looks suspicious to me.\n\n1. Why to use pointers here? It is a private structure, that is used by VideoProvider exclusively. And QVideoFrame is explicitly shared, as documentation says.\n```\n    struct FrameObject\n    {\n        std::unique_ptr\u003cQVideoFrame\u003e videoFrame;\n        QMutex mutex;\n        QSet\u003cQVideoSink*\u003e subscribers;\n    };\n    std::map\u003cQString, std::unique_ptr\u003cFrameObject\u003e\u003e framesObjects_;\n```\n\n2. Why two mutexes if we need three to be thread-safe?\n  a) One for adding and removing renderers.\n  b) One for adding and removing subscribers.\n  c) One for modifying QVideoFrame.\n\n3. Why QMutex instead of QReadWriteLock? Don\u0027t see any reason why a frame can\u0027t be read by multiple threads simultaneously. And for different frames locking-free reading is a must.\n\n4. Why to duplicate data in activeRenderers_ (and protect it by a mutex by the way) if it can be easily generated on demand?\n\nSo in my opinion the right design should look like this:\n```\nclass VideoProvider final : public QObject\n{\n    Q_OBJECT\n    QML_ELEMENT\npublic:\n    explicit VideoProvider(AVModel\u0026 avModel, QObject* parent \u003d nullptr);\n    ~VideoProvider() \u003d default;\n\n    Q_INVOKABLE void subscribe(QObject* obj, const QString\u0026 id \u003d {});\n    Q_INVOKABLE void unsubscribe(QObject* obj);\n    Q_INVOKABLE QString captureVideoFrame(const QString\u0026 id);\n    Q_INVOKABLE QImage captureRawVideoFrame(const QString\u0026 id);\n    \n    Q_PROPERTY(QVariantMap renderers READ getRenderers NOTIFY renderersChanged)\n    QVariantMap getRenderers() {\n        QVariantMap map;\n        for (auto\u0026 r : renderers_) {\n            map[r.first] \u003d r.second.videoFrame.size();\n        }\n        return map;\n    }\n    Q_SIGNAL void renderersChanged();\n\nprivate Q_SLOTS:\n    void onRendererStarted(const QString\u0026 id, const QSize\u0026 size);\n    void onFrameBufferRequested(const QString\u0026 id, AVFrame* avframe);\n    void onFrameUpdated(const QString\u0026 id);\n    void onRendererStopped(const QString\u0026 id);\n\nprivate:\n    QVideoFrame* frame(const QString\u0026 id);\n    void copyUnaligned(QVideoFrame* dst, const video::Frame\u0026 src);\n    AVModel\u0026 avModel_;\n\n    struct FrameObject\n    {\n        QVideoFrame videoFrame;\n        QReadWriteLock frameMutex;\n        QSet\u003cQVideoSink*\u003e subscribers;\n        QReadWriteLock subscribersMutex;\n    };\n    std::map\u003cQString, FrameObject\u003e renderers_;\n    QReadWriteLock renderersMutex_;\n};\n```\n\nAnd now if we add double buffering like this:\n```\nclass VideoProvider final : public QObject\n{\n    Q_OBJECT\n    QML_ELEMENT\npublic:\n    explicit VideoProvider(AVModel\u0026 avModel, QObject* parent \u003d nullptr);\n    ~VideoProvider() \u003d default;\n\n    Q_INVOKABLE void subscribe(QObject* obj, const QString\u0026 id \u003d {});\n    Q_INVOKABLE void unsubscribe(QObject* obj);\n    Q_INVOKABLE QString captureVideoFrame(const QString\u0026 id);\n    Q_INVOKABLE QImage captureRawVideoFrame(const QString\u0026 id);\n    \n    Q_PROPERTY(QVariantMap renderers READ getRenderers NOTIFY renderersChanged)\n    QVariantMap getRenderers() {\n        QVariantMap map;\n        for (auto\u0026 r : renderers_) {\n            map[r.first] \u003d r.second.videoFrame.size();\n        }\n        return map;\n    }\n    Q_SIGNAL void renderersChanged();\n\nprivate Q_SLOTS:\n    void onRendererStarted(const QString\u0026 id, const QSize\u0026 size);\n    void onFrameBufferRequested(const QString\u0026 id, AVFrame* avframe);\n    void onFrameUpdated(const QString\u0026 id);\n    void onRendererStopped(const QString\u0026 id);\n\nprivate:\n    QVideoFrame* frame(const QString\u0026 id);\n    void copyUnaligned(QVideoFrame* dst, const video::Frame\u0026 src);\n    AVModel\u0026 avModel_;\n\n    struct FrameObject\n    {\n        QVideoFrame frame1;\n        QVideoFrame frame2;\n        QSet\u003cQVideoSink*\u003e subscribers;\n        QReadWriteLock subscribersMutex;\n        std::atomic_flag indicator; // true  \u003d read from frame1, write to frame2\n                                    // false \u003d read from frame2, write to frame1\n    };\n    std::map\u003cQString, FrameObject\u003e renderers_;\n    QReadWriteLock renderersMutex_;\n};\n```\n\nHere I assume that we have one writer and multiple readers, which is our use-case. For multiple writers they should be serialized by a QReadWriteLock as earlier.\n\nDid I miss something and there is a reason to complicate things here?",
      "revId": "9ba688ac95f4eb3e8d0ba90f24d7769447dbf08e",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    }
  ]
}