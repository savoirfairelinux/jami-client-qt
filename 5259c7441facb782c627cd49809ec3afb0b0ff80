{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "06f23000_0cbc819b",
        "filename": "src/app/videoprovider.h",
        "patchSetId": 4
      },
      "lineNbr": 32,
      "author": {
        "id": 610
      },
      "writtenOn": "2023-05-06T19:33:54Z",
      "side": 1,
      "message": "Remove?",
      "revId": "5259c7441facb782c627cd49809ec3afb0b0ff80",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8bfa42dd_e1c52b2c",
        "filename": "src/app/videoprovider.h",
        "patchSetId": 4
      },
      "lineNbr": 32,
      "author": {
        "id": 90
      },
      "writtenOn": "2023-05-08T22:18:56Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "06f23000_0cbc819b",
      "revId": "5259c7441facb782c627cd49809ec3afb0b0ff80",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f8c7ec7b_c9456456",
        "filename": "src/app/videoprovider.h",
        "patchSetId": 4
      },
      "lineNbr": 32,
      "author": {
        "id": 90
      },
      "writtenOn": "2023-05-08T22:44:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8bfa42dd_e1c52b2c",
      "revId": "5259c7441facb782c627cd49809ec3afb0b0ff80",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e3bbdd6_c7c2ca96",
        "filename": "src/app/videoprovider.h",
        "patchSetId": 4
      },
      "lineNbr": 70,
      "author": {
        "id": 610
      },
      "writtenOn": "2023-05-06T19:33:54Z",
      "side": 1,
      "message": "Are you sure that this operation is thread-safe? Documentation says nothing about it.",
      "revId": "5259c7441facb782c627cd49809ec3afb0b0ff80",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0343ce80_4cc94e5e",
        "filename": "src/app/videoprovider.h",
        "patchSetId": 4
      },
      "lineNbr": 70,
      "author": {
        "id": 90
      },
      "writtenOn": "2023-05-08T22:18:56Z",
      "side": 1,
      "message": "Good point. AFAICS, the only way to prevent \"undefined behavior\" in the case of an upload during the swap would be to have both frames mapped write-only.",
      "parentUuid": "3e3bbdd6_c7c2ca96",
      "revId": "5259c7441facb782c627cd49809ec3afb0b0ff80",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6161198_7e5df7a0",
        "filename": "src/app/videoprovider.h",
        "patchSetId": 4
      },
      "lineNbr": 70,
      "author": {
        "id": 90
      },
      "writtenOn": "2023-05-08T22:44:08Z",
      "side": 1,
      "message": "I think the current sequence is:\n```\nsequenceDiagram\n    participant libjami\n    participant VideoProvider\n    participant Qml/QSGRenderThread\n    loop render cycle\n        alt DirectRenderer\n            libjami-\u003e\u003eVideoProvider: frameBufferRequested\n            VideoProvider-\u003e\u003elibjami: +w - frame2, wrap in AVFrame\n        end\n        libjami-\u003e\u003eVideoProvider: frameUpdated\n        alt ShmRenderer\n            VideoProvider-\u003e\u003eVideoProvider: +w - frame2, copy from SHM\n        end\n        VideoProvider-\u003e\u003eVideoProvider: make sure both frames are locked\n        VideoProvider-\u003e\u003eVideoProvider: swap them\n        VideoProvider-\u003e\u003eVideoProvider: make sure both frames are unmapped\n        VideoProvider--)Qml/QSGRenderThread: notify frame1 for upload\n    end\n    Qml/QSGRenderThread--)Qml/QSGRenderThread: +r frame1, upload\n```\n\nAnd I think this might be excessive. Docs say `This may involve copying the contents around, so avoid mapping and unmapping unless required`, and haven\u0027t seen any issues with the unprotected swap. Considering `If the map mode includes the QVideoFrame::ReadOnly flag the mapped memory will be populated with the content of the video frame when initially mapped`, and that the upload is queued, if it occurs during the swap, what would happen? I figured the \"undefined behavior\" would be some tearing, as both frames are the same format/size.\n\nWhat do you think?",
      "parentUuid": "0343ce80_4cc94e5e",
      "revId": "5259c7441facb782c627cd49809ec3afb0b0ff80",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6c4d078_f65c5acc",
        "filename": "src/app/videoprovider.h",
        "patchSetId": 4
      },
      "lineNbr": 70,
      "author": {
        "id": 610
      },
      "writtenOn": "2023-05-09T10:43:20Z",
      "side": 1,
      "message": "We sent frames to subscribers immediately we have got them (sink-\u003esetVideoFrame(frame) is called in onFrameUpdated()). After that we can\u0027t know when these frames will be mapped for reading, so we can\u0027t map these frames for writing. So we need to create a new QVideoFrame for each frame from the daemon. So double buffering is useless because we never write to the same buffer twice.\n\nSo the first question is why to use double buffering here? The only way to make the current design of pipeline robust is single buffering.",
      "parentUuid": "c6161198_7e5df7a0",
      "revId": "5259c7441facb782c627cd49809ec3afb0b0ff80",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62d160de_50fccc4b",
        "filename": "src/app/videoprovider.h",
        "patchSetId": 4
      },
      "lineNbr": 70,
      "author": {
        "id": 610
      },
      "writtenOn": "2023-05-09T11:15:09Z",
      "side": 1,
      "message": "\u003e we never write to the same buffer twice.\n\nIt should be \"we never write to the buffer that can be read.\"",
      "parentUuid": "e6c4d078_f65c5acc",
      "revId": "5259c7441facb782c627cd49809ec3afb0b0ff80",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a34aa109_b55aff2c",
        "filename": "src/app/videoprovider.h",
        "patchSetId": 4
      },
      "lineNbr": 70,
      "author": {
        "id": 610
      },
      "writtenOn": "2023-05-09T15:04:06Z",
      "side": 1,
      "message": "```\nclass VideoProvider final : public QObject\n{\n    \u003c...\u003e\n    struct FrameObject\n    {\n        QVideoFrame videoFrame;\n        QReadWriteLock frameMutex;\n        QSet\u003cQVideoSink*\u003e subscribers;\n        QReadWriteLock subscribersMutex;\n    };\n    std::map\u003cQString, FrameObject\u003e framesObjects_;\n    QReadWriteLock framesObjsMutex_;\n};\n\nvoid\nVideoProvider::onFrameBufferRequested(const QString\u0026 id, AVFrame* avframe)\n{\n    framesObjsMutex_.lockForRead();\n\n    auto it \u003d framesObjects_.find(id);\n    if (it \u003d\u003d framesObjects_.end()) {\n        return;\n    }\n    QVideoFrame\u0026 videoFrame \u003d it-\u003esecond.videoFrame;\n\n    it-\u003esecond.frameMutex.lockForWrite(); // because captureRawVideoFrame() can be called\n    videoFrame \u003d QVideoFrame(videoFrame.surfaceFormat()); // create a new QVideoFrame with the same format\n    if (!videoFrame-\u003emap(QVideoFrame::WriteOnly))) {\n        return;\n    }\n\n    // The ownership of avframe structure remains the subscriber(jamid), and\n    // the videoFrame instance is owned by the VideoProvider(client). The\n    // avframe structure contains only a description of the QVideoFrame\n    // underlying buffer.\n    // TODO: ideally, the colorspace format should likely come from jamid and\n    // be the decoded format.\n    avframe-\u003eformat \u003d AV_PIX_FMT_RGBA;\n    avframe-\u003ewidth \u003d videoFrame-\u003ewidth();\n    avframe-\u003eheight \u003d videoFrame-\u003eheight();\n    avframe-\u003edata[0] \u003d (uint8_t*) videoFrame-\u003ebits(0);\n    avframe-\u003elinesize[0] \u003d videoFrame-\u003ebytesPerLine(0);\n}\n\nvoid\nVideoProvider::onFrameUpdated(const QString\u0026 id)\n{\n    if (avModel_.useDirectRenderer()) {\n\n        auto it \u003d framesObjects_.find(id);\n        if (it \u003d\u003d framesObjects_.end()) {\n            return;\n        }\n        QVideoFrame\u0026 videoFrame \u003d it-\u003esecond.videoFrame;\n        videoFrame.unmap();\n        it-\u003esecond.frameMutex.unlock(); // locked by onFrameBufferRequested()\n\n        it-\u003esecond.frameMutex.lockForRead();\n        it-\u003esecond.subscribersMutex.lockForRead();\n        for (const auto\u0026 sink : qAsConst(it-\u003esecond.subscribers)) {\n            sink-\u003esetVideoFrame(videoFrame);\n            Q_EMIT sink-\u003evideoFrameChanged(videoFrame);\n        }\n        it-\u003esecond.subscribersMutex.unlock();\n        it-\u003esecond.frameMutex.unlock();\n\n        framesObjsMutex_.unlock();  // locked by onFrameBufferRequested()\n\n    } else {\n\n    QReadLocker framesLk(\u0026framesObjsMutex_);\n    auto it \u003d framesObjects_.find(id);\n    if (it \u003d\u003d framesObjects_.end()) {\n        return;\n    }\n    QVideoFrame\u0026 videoFrame \u003d it-\u003esecond.videoFrame;\n\n    it-\u003esecond.frameMutex.lockForWrite(); // because captureRawVideoFrame() can be called\n    videoFrame \u003d QVideoFrame(videoFrame.surfaceFormat()); // create a new QVideoFrame with the same format\n    if (!videoFrame-\u003emap(QVideoFrame::WriteOnly))) {\n        return;\n    }\n\n    auto srcFrame \u003d avModel_.getRendererFrame(id);\n    if (srcFrame.ptr !\u003d nullptr and srcFrame.size \u003e 0) {\n        copyUnaligned(videoFrame, srcFrame);\n    }\n\n    videoFrame.unmap();\n    it-\u003esecond.frameMutex.unlock();\n\n    it-\u003esecond.frameMutex.lockForRead();\n    it-\u003esecond.subscribersMutex.lockForRead();\n    for (const auto\u0026 sink : qAsConst(it-\u003esecond.subscribers)) {\n        sink-\u003esetVideoFrame(videoFrame);\n        Q_EMIT sink-\u003evideoFrameChanged(videoFrame);\n    }\n    it-\u003esecond.subscribersMutex.unlock();\n    it-\u003esecond.frameMutex.unlock();\n}\n```\n\nLooks robust. What do you think?",
      "parentUuid": "62d160de_50fccc4b",
      "revId": "5259c7441facb782c627cd49809ec3afb0b0ff80",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    }
  ]
}